# ADR-002: Manejo del estado conversacional

## Estado
Propuesto (PoC)

## Contexto
El asistente conversacional debe manejar múltiples conversaciones simultáneas,
cada una manteniendo su propio contexto y estado, bajo escenarios de alta concurrencia,
conectividad variable y uso desde dispositivos móviles.

El usuario puede:
- iniciar una conversación,
- abandonar la aplicación,
- volver más tarde y continuar el flujo,
  especialmente en procesos como triaje o agendamiento de citas.

Además:
- el sistema maneja datos sensibles de salud (PHI),
- no se requiere continuidad de conversación entre dispositivos,
- se busca minimizar complejidad y dependencia de conectividad constante.

Por lo tanto, es necesario decidir:
- dónde se almacena el estado conversacional,
- por cuánto tiempo persiste,
- cómo se recupera al reabrir la aplicación.

## Decisión
El estado conversacional se manejará de la siguiente manera:

1) **Estado asociado al usuario autenticado**
- Cada conversación se asocia a un usuario autenticado.
- No se soporta continuidad cross-device (ej. Android → iOS) en esta versión.

2) **Persistencia local en el dispositivo**
- El estado conversacional se persiste localmente en el dispositivo
  (ej. base de datos local o almacenamiento cifrado).
- Esto permite:
    - recuperación del contexto al reabrir la app,
    - operación bajo conectividad limitada,
    - reducción de latencia percibida.

3) **Tiempo de vida limitado**
- El estado conversacional persiste hasta **24 horas** desde la última interacción.
- Pasado ese tiempo, la conversación se considera expirada y se inicia una nueva.

4) **Backend opcional para evolución futura**
- En esta PoC, no se requiere persistencia obligatoria en backend.
- La arquitectura permite extender el diseño a un modelo híbrido
  (local + backend) si en el futuro se requiere continuidad cross-device
  o analítica avanzada.

## Alternativas consideradas

### 1) Estado conversacional únicamente en backend
**Pros**
- Facilita continuidad entre dispositivos.
- Centraliza observabilidad y control.

**Contras**
- Dependencia fuerte de conectividad.
- Mayor latencia percibida en móvil.
- Complica el requisito de operación bajo red intermitente.

---

### 2) Estado conversacional solo en memoria (no persistente)
**Pros**
- Implementación simple.
- Sin manejo de expiración.

**Contras**
- Mala experiencia al cerrar/reabrir la app.
- Flujos largos (triaje, citas) se pierden fácilmente.
- No cumple expectativas de usabilidad en móvil.

---

### 3) Estado conversacional por sesión anónima
**Pros**
- Simplifica login.
- Menor acoplamiento a identidad.

**Contras**
- Dificulta asociación a datos médicos.
- Riesgos adicionales en manejo de PHI.
- Menor control y trazabilidad.

## Trade-offs

### Beneficios
- **Mejor experiencia de usuario**: el flujo continúa tras cerrar la app.
- **Resiliencia**: menor dependencia de red para mantener contexto.
- **Privacidad**: datos limitados al dispositivo del usuario.
- **Simplicidad**: evita complejidad de sincronización cross-device.

### Costos / Riesgos
- No se soporta continuidad de conversación entre dispositivos.
- Se requiere manejo explícito de expiración y limpieza de estado local.
- Si el usuario cambia de dispositivo, la conversación se reinicia.

## Consecuencias
- El modelo de estado conversacional deberá ser serializable y versionable.
- Se definirá un mecanismo de expiración automática a las 24 horas.
- El asistente deberá informar claramente cuando una conversación haya expirado.
- La arquitectura queda preparada para una evolución futura hacia
  persistencia híbrida (local + backend) si los requisitos cambian.
