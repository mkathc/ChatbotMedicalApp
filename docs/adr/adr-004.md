# ADR-004: Contratos de orquestación — Tools / Commands (contract-first)

## Estado
Propuesto (PoC)

## Contexto
El asistente conversacional debe **orquestar múltiples capacidades** de la aplicación de salud:
- triaje de síntomas,
- agendamiento de citas,
- consulta de información médica,
- gestión de recordatorios.

Estas capacidades:
- pueden ejecutarse localmente (ej. triaje offline),
- pueden requerir backend (ej. citas, historial),
- deben ser intercambiables por stubs/fakes en la PoC,
- no deben acoplarse directamente al proveedor de IA ni a la UI.

Además, el sistema debe mantener **baja complejidad cognitiva** y permitir que otros desarrolladores evolucionen los módulos sin conocer detalles internos de la conversación o del proveedor de IA.

Por ello, se requiere una forma clara y estable de:
- expresar *qué quiere hacer el usuario*,
- ejecutar capacidades de negocio,
- devolver resultados estructurados al asistente.

## Decisión
Adoptar un enfoque **contract-first** basado en **Tools / Commands**, donde el asistente (online u offline) **no ejecuta lógica de negocio directamente**, sino que orquesta capacidades mediante contratos explícitos.

### 1) Commands (intención estructurada)
Cada acción relevante se modela como un **Command** explícito y validable, por ejemplo:
- `RunTriageCommand`
- `ScheduleAppointmentCommand`
- `ModifyAppointmentCommand`
- `CancelAppointmentCommand`
- `GetMedicalInfoCommand`
- `CreateReminderCommand`

Los commands contienen únicamente:
- datos necesarios para ejecutar la acción,
- sin conocimiento de UI, conversación o proveedor IA.

### 2) Tools (capacidad de negocio)
Cada capacidad se expone como una **Tool** con una interfaz simple y estable:

```text
Tool {
  canHandle(command): Boolean
  execute(command): ToolResult
}
```
Ejemplos de Tools:
- `TriageTool`
- `SchedulingTool`
- `MedicalRecordsTool`
- `RemindersTool`

Cada Tool:
- encapsula su complejidad interna (*deep module*),
- puede ejecutarse localmente o vía backend,
- puede tener implementación real, fake o stub.

---

### 3) Orquestación desacoplada
El asistente (ya sea en backend/BFF o en modo offline local):

1. interpreta la intención (NLP o reglas),
2. construye un `Command`,
3. selecciona la `Tool` adecuada,
4. ejecuta la Tool,
5. recibe un `ToolResult` estructurado.

La conversación y la UI **solo consumen resultados**; no conocen ni dependen de la lógica de negocio.

---

## Alternativas consideradas

### A) Lógica de negocio embebida en el asistente
**Pros**
- Implementación rápida para una PoC simple.

**Contras**
- Alto acoplamiento entre conversación y dominio.
- Difícil testeo y evolución.
- Cambios conversacionales rompen lógica de negocio.

---

### B) Llamadas directas desde la conversación a servicios específicos
**Pros**
- Menos capas aparentes.

**Contras**
- El asistente debe conocer detalles de cada servicio.
- Difícil de extender o simular (stubs/fakes).
- Mayor complejidad cognitiva.

---

## Trade-offs

### Beneficios
- **Baja complejidad cognitiva**: cada módulo tiene una responsabilidad clara.
- **Testabilidad**: Tools y Commands se prueban sin IA ni UI.
- **Flexibilidad**: permite stubs/fakes en PoC y reemplazos en producción.
- **Alineación con IA**: facilita *tool-calling* desde LLM sin acoplar dominio al proveedor.
- **Escalabilidad**: nuevas capacidades no rompen el sistema existente.

### Costos / Riesgos
- Requiere disciplina inicial para definir contratos claros.
- Introduce una capa adicional de abstracción.
- Puede percibirse como “overengineering” si no se documenta adecuadamente.

---

## Consecuencias
- El dominio de la app se modela como **capacidades explícitas**, no como flujos conversacionales.
- El backend/BFF puede exponer las mismas Tools que el cliente consume localmente (según capacidad).
- El proveedor de IA puede **sugerir Commands**, pero nunca ejecutar lógica directamente.
- La PoC puede usar:
  - `FakeSchedulingTool`
  - `FakeMedicalRecordsTool`
  - reglas reales en `TriageTool` offline.
- La arquitectura queda preparada para producción **sin cambios estructurales**.
