# ADR-006: Resiliencia — timeouts, retries y degradación controlada

## Estado
Propuesto (PoC)

## Contexto
La aplicación móvil de salud debe operar bajo escenarios comunes de:
- conectividad intermitente (3G, latencia elevada),
- fallos parciales de servicios externos,
- indisponibilidad temporal del proveedor de IA.

El enunciado del reto requiere explícitamente que el sistema demuestre:
- resiliencia ante fallos,
- degradación elegante,
- comportamiento predecible sin red o sin IA.

Además, el uso en dispositivos móviles impone restricciones de batería, memoria y latencia percibida.

## Decisión
Adoptar una estrategia de **resiliencia explícita y controlada**, basada en:
- timeouts agresivos,
- retries limitados con backoff,
- circuit breakers por dependencia,
- degradación funcional clara para el usuario.

### 1) Timeouts por defecto
Toda llamada remota (backend/BFF, servicios médicos, proveedor IA) debe:
- tener timeouts definidos explícitamente,
- evitar bloqueos prolongados en UI o conversación.

En móvil, se prioriza:
- respuestas rápidas,
- fallback temprano en lugar de esperar indefinidamente.

### 2) Retries con backoff (cuando aplique)
- Retries se aplican solo a operaciones **idempotentes** o seguras.
- Se utiliza backoff exponencial con jitter.
- Se limita el número de intentos para evitar consumo excesivo de batería o red.

Ejemplos:
- reintentar consulta de disponibilidad médica,
- no reintentar automáticamente acciones críticas sin confirmación del usuario.

### 3) Circuit breaker por dependencia
Se define un circuito por cada dependencia externa relevante:
- proveedor de IA,
- servicios de citas,
- servicios de historial médico.

Cuando un circuito está abierto:
- se evita seguir llamando al servicio fallido,
- se activa inmediatamente la ruta de degradación.

### 4) Degradación funcional
Ante fallos:
- **Triaje**: se utiliza el motor local offline (ADR-005).
- **Agendamiento / historial**: se informa al usuario y se sugiere reintento o uso manual.
- **Conversación**: se mantiene el flujo guiado, aunque con capacidades limitadas.

El usuario recibe mensajes claros del tipo:
> “Algunas funciones están temporalmente limitadas por la conexión. Puedes reintentar más tarde.”

### 5) Cola local (opcional en evolución)
Para acciones no críticas:
- se puede usar una cola local simple para ejecutar cuando vuelva la conectividad.
- esta capacidad se deja como evolución futura y no es obligatoria en la PoC.

## Alternativas consideradas

### A) Retries simples sin control
**Pros**
- Implementación rápida.

**Contras**
- Riesgo de loops.
- Consumo innecesario de batería y red.
- Comportamiento impredecible.

---

### B) Falla dura sin degradación
**Pros**
- Lógica simple.

**Contras**
- Mala experiencia de usuario.
- No cumple requisitos de resiliencia del reto.
- Especialmente riesgoso en contexto de salud.

## Trade-offs

### Beneficios
- **Experiencia predecible**: el usuario entiende qué ocurre cuando algo falla.
- **Estabilidad**: se evita cascada de fallos.
- **Performance móvil**: menos consumo de recursos.
- **Escalabilidad**: protege servicios backend y proveedor IA.

### Costos / Riesgos
- Más estados a manejar en UI y conversación.
- Requiere coordinación clara entre módulos para fallback.
- Necesita documentación clara para mantenimiento.

## Consecuencias
- Cada dependencia externa debe declarar su política de resiliencia.
- El asistente conversacional debe conocer estados degradados y comunicar límites.
- La arquitectura cumple el requisito de degradación elegante sin complejidad excesiva.
- El sistema queda preparado para escalar y operar bajo fallos parciales.
