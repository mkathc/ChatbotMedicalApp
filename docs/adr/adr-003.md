# ADR-003: Visión multiplataforma — UI nativa + core compartido (KMP) con BFF en producción

## Estado
Propuesto (PoC)

## Contexto
El sistema debe soportar aplicaciones móviles en **Android e iOS** y, a la vez, minimizar duplicación de lógica core entre plataformas. Se busca mantener baja complejidad cognitiva y permitir evolución a escala.

Para esta entrega:
- La PoC se implementará en **Android**.
- iOS se documenta como **visión arquitectónica** (misma separación de responsabilidades y contratos).

Además, por manejo de datos sensibles (PHI) y por capacidad de cambiar/iterar proveedor de IA sin depender de releases móviles, se necesita definir dónde vive la integración con IA.

## Decisión
Adoptar una estrategia multiplataforma con los siguientes principios:

1) **UI nativa por plataforma**
- Android: UI nativa (Compose / View system según PoC).
- iOS: UI nativa (SwiftUI / UIKit como visión).
- Motivación: mejor control de performance, accesibilidad, UX y comportamiento móvil; reduce riesgo de jank y facilita optimizaciones específicas por plataforma.

2) **Core compartido con Kotlin Multiplatform (KMP) como visión**
Se reutilizará (como objetivo arquitectónico) lógica core no-UI en un módulo compartido:
- modelos de dominio y contratos (intents/actions/commands),
- reglas mínimas determinísticas del triaje (offline-capable),
- modelado del estado conversacional (serializable, versionable),
- políticas de degradación (offline/online) y mapeo de errores.

En la PoC Android este core puede implementarse localmente en Kotlin con una estructura preparada para extraerse a KMP.

La lógica del core compartido es principalmente determinística y offline-capable; la IA basada en LLM se ejecuta en backend vía BFF.

3) **BFF en producción para IA y políticas (no SDK de IA en el cliente)**
- En la visión de producción, la app **no** integra SDKs/llaves del proveedor de IA.
- Un **BFF/Backend** actúa como punto de integración con proveedores de IA y como “policy enforcement point”:
    - aplica minimización/redacción de PHI,
    - controla rate limiting,
    - centraliza auditoría y observabilidad segura,
    - permite cambiar de proveedor mediante adapters sin modificar la app.
- El cliente móvil consume respuestas estructuradas (texto + acciones) y ejecuta flujos determinísticos localmente.

## Alternativas consideradas

### A) Flutter (UI + lógica compartida)
**Pros**
- Máxima reutilización de UI y lógica.
- Velocidad de entrega con un solo stack.

**Contras**
- Menor control fino de performance y comportamiento específico móvil en casos complejos.
- Posible fricción con necesidades de accesibilidad, integraciones nativas, y optimizaciones por plataforma.
- Implica cambio de stack/skillset y dependencia fuerte del framework.

---

### B) Nativo duplicando toda la lógica (sin core compartido)
**Pros**
- Máxima libertad por plataforma, sin complejidad de shared core.

**Contras**
- Alto costo de mantenimiento.
- Riesgo de divergencia funcional entre Android/iOS.
- Duplicación de reglas críticas (ej. triaje offline) con alto riesgo de inconsistencia.

---

### C) Cliente delgado + todo en backend (incluyendo estado persistente)
**Pros**
- Cambios rápidos sin releases móviles.
- Centraliza lógica y observabilidad.

**Contras**
- Dependencia fuerte de conectividad (problemático en 3G/intermitente).
- Dificulta requisito de triaje inicial offline.
- Aumenta latencia percibida en móvil.

## Trade-offs

### Beneficios
- **Performance y UX**: UI nativa optimizada por plataforma.
- **Consistencia**: core compartido reduce duplicación y divergencias.
- **Seguridad/privacidad**: BFF evita exponer llaves/SDKs de IA en el cliente y centraliza políticas de PHI.
- **Evolución**: cambiar proveedor de IA es un cambio backend (adapters), no un release móvil.

### Costos / Riesgos
- KMP agrega complejidad de tooling y disciplina de modularización (core vs UI).
- Requiere acuerdos claros sobre qué va al core y qué queda en UI por plataforma.
- BFF agrega un salto de red (RTT) en modo online; debe mitigarse con timeouts, retries y degradación elegante.

## Consecuencias
- Definir límites estrictos entre:
    - UI nativa (presentación),
    - core compartido (reglas, contratos, estado),
    - backend/BFF (IA, políticas, orquestación online, auditoría).
- La PoC Android deberá estructurarse por módulos/paquetes para facilitar extracción a KMP.
- La integración con proveedores de IA será contract-first mediante ports/adapters en backend (y stubs/fakes para PoC).
